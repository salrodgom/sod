!*******************************************************************************
!  Computes configurational entropies from OUTSOD_Nxxxx files generated by the
!  exhaustive enumerator. Energies are not required; only degeneracy counts are
!  used to evaluate S_conf = k_B ln W for each substitution level.
!*******************************************************************************
program sod_config_entropy
    use sod_boltzmann_consts
    use, intrinsic :: iso_fortran_env, only: output_unit, error_unit
    implicit none

    integer, parameter :: max_scan_level = 9999
    real(dp), parameter :: ev_to_joule = 1.602176634d-19
    real(dp), parameter :: avogadro = 6.02214076d23

    integer :: level_min, level_max
    integer, allocatable :: level_targets(:)
    logical :: has_list
    integer :: total_sites_hint
    logical :: found_reference
    integer :: ref_total_sites
    integer :: idx, level
    integer :: summary_unit
    character(len=*), parameter :: summary_name = 'sod_entropy_summary.csv'
    logical :: any_level

    call parse_arguments(level_min, level_max, level_targets, has_list)

    ref_total_sites = -1
    found_reference = detect_reference_sites(ref_total_sites)
    if (.not. found_reference) then
        write(error_unit,'(A)') 'Error: no se encontraron archivos OUTSOD_Nxxxx en el directorio actual.'
        stop 1
    end if

    if (.not. has_list) then
        if (level_max < 0) level_max = ref_total_sites
        if (level_min < 0) level_min = 0
        level_min = max(0, min(level_min, ref_total_sites))
        level_max = max(level_min, min(level_max, ref_total_sites))
    else
        call sanitize_level_list(level_targets, ref_total_sites)
    end if

    call init_summary(summary_unit, summary_name)

    write(*,'(A)') '--- Entropia configuracional basada en OUTSOD ---'
    write(*,'(A,I0)') 'Sitios sustituibles (npos): ', ref_total_sites
    if (has_list) then
        write(*,'(A)', advance='no') 'Niveles evaluados (lista): '
        do idx = 1, size(level_targets)
            write(*,'(I0)', advance='no') level_targets(idx)
            if (idx < size(level_targets)) write(*,'(A)', advance='no') ' '
        end do
        write(*,*)
    else
        write(*,'(A,I0,A,I0)') 'Niveles evaluados: ', level_min, ' .. ', level_max
    end if
    write(*,*)

    any_level = .false.
    if (has_list) then
        do idx = 1, size(level_targets)
            level = level_targets(idx)
            call process_level(level, ref_total_sites, summary_unit, any_level)
        end do
    else
        do level = level_min, level_max
            call process_level(level, ref_total_sites, summary_unit, any_level)
        end do
    end if

    close(summary_unit)

    if (.not. any_level) then
        write(error_unit,'(A)') 'Aviso: no se pudo procesar ningun nivel; revise los archivos OUTSOD.'
        stop 1
    end if

contains

    subroutine parse_arguments(level_min, level_max, level_list, has_list)
        implicit none
        integer, intent(out) :: level_min, level_max
        integer, allocatable, intent(out) :: level_list(:)
        logical, intent(out) :: has_list
        integer :: argc, iarg
        character(len=256) :: arg, spec

        level_min = 0
        level_max = -1
        has_list = .false.
        allocate(level_list(0))

        argc = command_argument_count()
        if (argc >= 1) then
            call get_command_argument(1, arg)
            if (is_help_token(arg)) then
                call print_usage()
                stop 0
            end if
        end if

        iarg = 1
        do while (iarg <= argc)
            call get_command_argument(iarg, arg)
            select case (trim(adjustl(arg)))
            case ('-N','-n')
                if (iarg + 1 > argc) then
                    write(error_unit,'(A)') 'Error: falta especificacion despues de -N.'
                    call print_usage()
                    stop 1
                end if
                call get_command_argument(iarg + 1, spec)
                call parse_level_spec(spec, level_min, level_max, level_list, has_list)
                iarg = iarg + 2
            case ('--help','-h','--ayuda','-ayuda','ayuda')
                call print_usage()
                stop 0
            case default
                write(error_unit,'(A)') 'Error: argumento no reconocido. Use --help para mas informacion.'
                call print_usage()
                stop 1
            end select
        end do
    end subroutine parse_arguments

    subroutine parse_level_spec(spec, level_min, level_max, level_list, has_list)
        implicit none
        character(len=*), intent(in) :: spec
        integer, intent(inout) :: level_min, level_max
        integer, allocatable, intent(inout) :: level_list(:)
        logical, intent(inout) :: has_list
        integer :: colon_pos, comma_pos
        integer :: value, ios
        character(len=len(spec)) :: token
        character(len=256) :: part
        integer, allocatable :: temp(:)
        integer :: count, start, finish, i

        colon_pos = index(spec, ':')
        comma_pos = index(spec, ',')

        if (colon_pos > 0 .and. comma_pos > 0) then
            write(error_unit,'(A)') 'Error: no mezcle rangos y listas en la misma especificacion -N.'
            stop 1
        end if

        if (comma_pos > 0) then
            has_list = .true.
            count = 0
            allocate(temp(0))
            start = 1
            do
                finish = index(spec(start:), ',')
                if (finish == 0) then
                    part = adjustl(spec(start:))
                else
                    part = adjustl(spec(start:start+finish-2))
                end if
                read(part, *, iostat=ios) value
                if (ios /= 0) then
                    write(error_unit,'(A)') 'Error: especificacion de nivel invalida en lista -N.'
                    stop 1
                end if
                call append_value(temp, count, value)
                if (finish == 0) exit
                start = start + finish
            end do
            call move_alloc(temp, level_list)
        else if (colon_pos > 0) then
            has_list = .false.
            read(spec(1:colon_pos-1), *, iostat=ios) level_min
            if (ios /= 0) then
                write(error_unit,'(A)') 'Error: limite inferior invalido en -N.'
                stop 1
            end if
            read(spec(colon_pos+1:), *, iostat=ios) level_max
            if (ios /= 0) then
                write(error_unit,'(A)') 'Error: limite superior invalido en -N.'
                stop 1
            end if
        else
            read(spec, *, iostat=ios) value
            if (ios /= 0) then
                write(error_unit,'(A)') 'Error: especificacion -N invalida.'
                stop 1
            end if
            if (value < 0) then
                level_min = 0
                level_max = -1
                has_list = .false.
            else
                level_min = value
                level_max = value
                has_list = .false.
            end if
        end if
    end subroutine parse_level_spec

    subroutine append_value(vec, count, value)
        implicit none
        integer, allocatable, intent(inout) :: vec(:)
        integer, intent(inout) :: count
        integer, intent(in) :: value
        integer, allocatable :: tmp(:)

        count = count + 1
        allocate(tmp(count))
        if (count > 1) tmp(1:count-1) = vec(1:count-1)
        tmp(count) = value
        if (allocated(vec)) deallocate(vec)
        call move_alloc(tmp, vec)
    end subroutine append_value

    logical function is_help_token(raw)
        implicit none
        character(len=*), intent(in) :: raw
        character(len=len(raw)) :: token
        integer :: i

        token = adjustl(raw)
        do i = 1, len_trim(token)
            token(i:i) = achar(iachar(token(i:i)) + merge(32, 0, token(i:i) >= 'A' .and. token(i:i) <= 'Z'))
        end do
        select case (trim(token))
        case ('--help','-h','help','--ayuda','-ayuda','ayuda','/h','/?')
            is_help_token = .true.
        case default
            is_help_token = .false.
        end select
    end function is_help_token

    subroutine print_usage()
        implicit none
        write(*,'(A)') 'Uso: sod_config_entropy [-N <especificacion>]' 
        write(*,'(A)') ''
        write(*,'(A)') '  -N espec   Define los niveles a evaluar:'
        write(*,'(A)') '             -N -1            -> todos los niveles disponibles'
        write(*,'(A)') '             -N 12            -> solo el nivel 12'
        write(*,'(A)') '             -N 3:8           -> niveles 3 a 8'
        write(*,'(A)') '             -N 5,9,11        -> lista puntual (orden preservado)'
        write(*,'(A)') ''
        write(*,'(A)') 'El programa lee los archivos OUTSOD_Nxxxx del directorio actual y calcula'
        write(*,'(A)') 'la entropia configuracional S = k_B ln W usando las degeneraciones listadas.'
        write(*,'(A)') 'El resultado agregado se guarda en sod_entropy_summary.csv.'
    end subroutine print_usage

    logical function detect_reference_sites(total_sites)
        implicit none
        integer, intent(out) :: total_sites
        integer :: level
        logical :: ok
        integer :: dummy_unique
        total_sites = -1
        detect_reference_sites = .false.
        do level = 0, max_scan_level
            ok = read_outsod_header(level, total_sites, dummy_unique)
            if (ok) then
                detect_reference_sites = .true.
                return
            end if
        end do
    end function detect_reference_sites

    logical function read_outsod_header(level, total_sites, unique_configs)
        implicit none
        integer, intent(in) :: level
        integer, intent(out) :: total_sites, unique_configs
        character(len=32) :: outsod_name
        integer :: unit, ios
        character(len=256) :: line
        character(len=32) :: word
        integer :: dummy_level

        write(outsod_name,'("OUTSOD_N",I4.4)') level
        inquire(file=trim(outsod_name), exist=read_outsod_header)
        if (.not. read_outsod_header) then
            total_sites = -1
            unique_configs = 0
            return
        end if

        open(newunit=unit, file=trim(outsod_name), status='old', action='read', iostat=ios)
        if (ios /= 0) then
            read_outsod_header = .false.
            total_sites = -1
            unique_configs = 0
            return
        end if

        read(unit,'(A)', iostat=ios) line
        if (ios /= 0) then
            close(unit)
            read_outsod_header = .false.
            total_sites = -1
            unique_configs = 0
            return
        end if

        read(line,*, iostat=ios) dummy_level, word, word, total_sites
        if (ios /= 0) then
            close(unit)
            read_outsod_header = .false.
            total_sites = -1
            unique_configs = 0
            return
        end if

        read(unit,'(A)', iostat=ios) line
        if (ios /= 0) then
            close(unit)
            read_outsod_header = .false.
            total_sites = -1
            unique_configs = 0
            return
        end if
        read(line,*, iostat=ios) unique_configs
        if (ios /= 0) then
            unique_configs = 0
        end if

        close(unit)
        read_outsod_header = .true.
    end function read_outsod_header

    subroutine sanitize_level_list(level_list, total_sites)
        implicit none
        integer, allocatable, intent(inout) :: level_list(:)
        integer, intent(in) :: total_sites
        integer :: i, j
        integer, allocatable :: filtered(:)
        integer :: count
        logical :: exists

        count = 0
        allocate(filtered(0))
        do i = 1, size(level_list)
            if (level_list(i) < 0 .or. level_list(i) > total_sites) cycle
            exists = .false.
            do j = 1, count
                if (filtered(j) == level_list(i)) then
                    exists = .true.
                    exit
                end if
            end do
            if (exists) cycle
            call append_value(filtered, count, level_list(i))
        end do
        if (allocated(level_list)) deallocate(level_list)
        call move_alloc(filtered, level_list)
    end subroutine sanitize_level_list

    subroutine init_summary(unit, filename)
        implicit none
        integer, intent(out) :: unit
        character(len=*), intent(in) :: filename
        integer :: ios

        open(newunit=unit, file=trim(filename), status='replace', action='write', iostat=ios)
        if (ios /= 0) then
            write(error_unit,'(A)') 'Error: no se pudo crear el archivo de resumen.'
            stop 1
        end if
        write(unit,'(A)') '#N,FracGe,UniqueConfigs,TotalWeight,Log10TotalWeight,S_conf_eV_per_K,S_conf_per_site_eV_per_K,'// &
            'S_conf_J_per_K_mol,S_max_eV_per_K,S_ideal_eV_per_K,EntropyReduction_eV_per_K'
    end subroutine init_summary

    subroutine process_level(level, ref_total_sites, summary_unit, any_level)
        implicit none
        integer, intent(in) :: level, ref_total_sites, summary_unit
        logical, intent(inout) :: any_level
        logical :: success
        integer :: total_sites, unique_configs
        real(dp) :: total_weight, log_total_weight
        real(dp) :: frac_ge
        real(dp) :: s_conf, s_conf_per_site, s_conf_per_mol
        real(dp) :: s_max, s_ideal, reduction
        real(dp) :: log_total_comb
        real(dp) :: total_comb_est

        call compute_entropy(level, ref_total_sites, total_sites, unique_configs, total_weight, log_total_weight, log_total_comb, s_conf, s_max, s_ideal, success)

        if (.not. success) then
            return
        end if

        any_level = .true.

        if (total_weight <= 0.0_dp) then
            s_conf = 0.0_dp
            log_total_weight = -huge(1.0_dp)
        end if

        frac_ge = 0.0_dp
        if (total_sites > 0) frac_ge = real(level, dp) / real(total_sites, dp)

        if (total_sites > 0) then
            s_conf_per_site = s_conf / real(total_sites, dp)
        else
            s_conf_per_site = 0.0_dp
        end if
        s_conf_per_mol = s_conf * ev_to_joule * avogadro
        reduction = s_max - s_conf

        write(*,'(A)') repeat('-', 72)
        write(*,'(A,I0)') 'Nivel: ', level
        write(*,'(A,I0)') 'Sitios totales (npos): ', total_sites
        write(*,'(A,I0)') 'Configuraciones unicas: ', unique_configs
        write(*,'(A,1PE15.6)') 'Peso total (sum degeneraciones): ', total_weight
        if (log_total_weight > -huge(1.0_dp)/2.0_dp) then
            write(*,'(A,F12.6)') 'k_B ln W [eV/K]: ', s_conf
        else
            write(*,'(A)') 'k_B ln W [eV/K]:    --'
        end if
        write(*,'(A,F12.6)') 'Entropia maxima (sin simetria) [eV/K]: ', s_max
        write(*,'(A,F12.6)') 'Entropia ideal (mezcla binaria) [eV/K]: ', s_ideal
        write(*,'(A,F12.6)') 'Entropia por sito [eV/K]: ', s_conf_per_site
        write(*,'(A,F12.6)') 'Entropia molar [J/K/mol]: ', s_conf_per_mol
        write(*,'(A,F12.6)') 'Reduccion (S_max - S_conf) [eV/K]: ', reduction
        call flush(output_unit)

        write(summary_unit,'(I0,",",F7.4,",",I0,",",ES16.8,",",F12.6,",",F12.6,",",F12.6,",",F12.6,",",F12.6,",",F12.6,",",F12.6)') &
            level, frac_ge, unique_configs, total_weight, log10_from_log(log_total_weight), s_conf, s_conf_per_site, &
            s_conf_per_mol, s_max, s_ideal, reduction
    end subroutine process_level

    subroutine compute_entropy(level, ref_total_sites, total_sites, unique_configs, total_weight, log_total_weight, log_total_comb, s_conf, s_max, s_ideal, success)
        implicit none
        integer, intent(in) :: level, ref_total_sites
        integer, intent(out) :: total_sites, unique_configs
        real(dp), intent(out) :: total_weight, log_total_weight, log_total_comb
        real(dp), intent(out) :: s_conf, s_max, s_ideal
        logical, intent(out) :: success
        character(len=32) :: outsod_name
        integer :: unit, ios
        character(len=256) :: line
        integer :: idx, deg
        real(dp) :: sum_deg
        integer :: header_level, header_sites
        character(len=32) :: word
        integer :: header_configs
        real(dp) :: frac

        write(outsod_name,'("OUTSOD_N",I4.4)') level
        inquire(file=trim(outsod_name), exist=success)
        if (.not. success) then
            return
        end if

        open(newunit=unit, file=trim(outsod_name), status='old', action='read', iostat=ios)
        if (ios /= 0) then
            success = .false.
            return
        end if

        read(unit,'(A)', iostat=ios) line
        if (ios /= 0) then
            close(unit)
            success = .false.
            return
        end if
        read(line,*, iostat=ios) header_level, word, word, header_sites
        if (ios /= 0) then
            close(unit)
            success = .false.
            return
        end if

        read(unit,'(A)', iostat=ios) line
        if (ios /= 0) then
            close(unit)
            success = .false.
            return
        end if
        read(line,*, iostat=ios) header_configs
        if (ios /= 0) header_configs = 0

        sum_deg = 0.0_dp
        unique_configs = 0
        do
            read(unit,*, iostat=ios) idx, deg
            if (ios /= 0) exit
            sum_deg = sum_deg + real(deg, dp)
            unique_configs = unique_configs + 1
        end do
        close(unit)

        total_sites = header_sites
        if (ref_total_sites >= 0 .and. total_sites /= ref_total_sites) then
            write(error_unit,'(A,I0,A,I0)') 'Aviso: OUTSOD_N', level, ' indica npos=', total_sites, &
                ' distinto al de referencia.'
        end if

        total_weight = sum_deg
        if (total_weight > 0.0_dp) then
            log_total_weight = log(total_weight)
            s_conf = kB_eVk * log_total_weight
        else
            log_total_weight = -huge(1.0_dp)
            s_conf = 0.0_dp
        end if

        log_total_comb = log_binomial_real(total_sites, level)
        s_max = kB_eVk * log_total_comb

        if (total_sites > 0) then
            frac = real(level, dp) / real(total_sites, dp)
            if (frac <= 0.0_dp .or. frac >= 1.0_dp) then
                s_ideal = 0.0_dp
            else
                s_ideal = -real(total_sites, dp) * kB_eVk * (frac * log(frac) + (1.0_dp - frac) * log(1.0_dp - frac))
            end if
        else
            s_ideal = 0.0_dp
        end if

        success = .true.
    end subroutine compute_entropy

    real(dp) function log_binomial_real(n, k)
        implicit none
        integer, intent(in) :: n, k
        real(dp) :: nn, kk
        if (k < 0 .or. k > n) then
            log_binomial_real = -huge(1.0_dp)
            return
        end if
        if (k == 0 .or. k == n) then
            log_binomial_real = 0.0_dp
            return
        end if
        nn = real(n + 1, dp)
        kk = real(k + 1, dp)
        log_binomial_real = log_gamma(nn) - log_gamma(kk) - log_gamma(real(n - k + 1, dp))
    end function log_binomial_real

    real(dp) function log10_from_log(log_x)
        implicit none
        real(dp), intent(in) :: log_x
        real(dp), parameter :: ln10 = log(10.0_dp)
        if (log_x <= -huge(1.0_dp)/4.0_dp) then
            log10_from_log = -999.0_dp
        else
            log10_from_log = log_x / ln10
        end if
    end function log10_from_log

end program sod_config_entropy